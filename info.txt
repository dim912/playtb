
#create using sbt seed
sbt new playframework/play-java-seed.g8

#main concepts
--------------

All Scala APIs => play.api
All Java APIS =>  play.mvc

Play - Concepts
----------------

Action -> java method process request parameters and produce the result

public Result index(String name) {
    return ok("Hello " + name);
}
The parameters to Action are resolved by the Router. filled with the values from URL.(URL path or query parametrs)


Controller -> controller groups several action methods -> extends play.mvc.Controller

Result
------
Defined in play.mvc.Result an play.mvc.Results

Sample Responses

        return ok("Got Request :" + request() + " !");
        Result ok = ok("Hello world!");
        Result notFound = notFound();
        Result pageNotFound = notFound("<h1>Page not found</h1>").as("text/html");
        Result badRequest = badRequest(views.html.form.render(formWithErrors));
        Result oops = internalServerError("Oops");
        Result anyStatus = status(488, "Strange response type");

Redirects
---------

Redirect browser to a new URL, is also a result

 return redirect("/user/home"); //this sends 303 SEE_OTHER response code

HTTP Routing
------------

=> converts each incomming HTTP request to an action(and call a public method in a controller class)
=> HTTP request is seen as an event by MVC framework (same as in Servlets)
=> Event contain two major info
        a. request path /client/1334
        b. Mehtod GET,POST

Dependency Injection
 ------------------

Plays default routes generator
    => create a router class that accepts controller instances in an @Inject annotated constructor

=> Regular expression matches are possible in route paths

=> router modifiers are possible in routes
Ex : to bypass CSRF filter
+ nocsrf
POST  /api/new              controllers.Api.newThing()

paramemtes with default, fixed values are possible

# Pagination links, like /clients?page=3
GET   /clients              controllers.Clients.list(page: Int ?= 1)

# The version parameter is optional. E.g. /api/list-all?version=3.0
GET   /api/list-all         controllers.Api.list(version ?= null)


Default Controller
------------------
# Redirects to https://www.playframework.com/ with 303 See Other
GET   /about      controllers.Default.redirect(to = "https://www.playframework.com/")

# Responds with 404 Not Found
GET   /orders     controllers.Default.notFound

# Responds with 500 Internal Server Error
GET   /clients    controllers.Default.error

# Responds with 501 Not Implemented
GET   /posts      controllers.Default.todo


Manupulating the Response
--------------------------

=> Auto Detected looking at the body passed to ok method.

JsonNode json = Json.toJson(object);
Result jsonResult = ok(json);
will set the Content-Type header to application/json.

Setting context type header manually
------------------------------------
Result htmlResult = ok("<h1>Hello World!</h1>").as("text/html");


Session and Flash scopes
------------------------

Session - available during whole session
Flash - available to the next request


Important - Unlike servlets => play maintain Session, flash data in cookies(4kb max)
*cookies are signed with a secret key(if client modify => gets invalid)


Play session => should not be used as a cache.

For cache => Play built-in cache can be used(session Id as cache key )

Session cookies
---------------

configured on application.conf

session Timeout
----------------
=> by default => no timeout
if needed
set => play.http.session.maxAge in application.conf
this will set play.http.session.jwt.expiresAfter to the same value auto.

Flash Scope
-----------
=> kept only for one request
=> not signed => meaning client can modify them

=> could subject to race conditions.

=> should only be used to trasposrt success/error messages.


Ex : After saving an item, routing to home page and how a "success" message on page

Ex:
public Result save() {
    flash("success", "The item has been created");
    return redirect("/home");
}

public Result index() {
    String message = flash("success");
    if(message == null) {
        message = "Welcome!";
    }
    return ok(message);
}


Body Parser
------------

Since the header is smalled => it is get prased to a
But body is bigger => it is not buffered to memory => and modled as a stream
=> if needs to body to get parsed into an Object => use BodyParser

Since Play is Asynchronouse => traditional blocking input streams are not suitable
=> so play use "Akka Streams"

=> If no body praser is selected
    => play prasers accordingly looking at Content-Type header

application/json => is prased as a JsonNode
application/x-www-form-urlencoded => as Map<Strin,String[]>

body can be assed through body() method on Request
wrapped in RequestBody object

public Result index() {
    JsonNode json = request().body().asJson();
    return ok("Got name: " + json.get("name").asText());
}



























